package com.kuro.notiflow.data.framework.importer

import com.kuro.notiflow.domain.models.notifications.NotificationModel

/**
 * A singleton utility object for mapping CSV/Excel data to [NotificationModel].
 *
 * This object provides a centralized and consistent way to handle the logic for:
 * 1.  Normalizing and mapping header names to their corresponding column indices.
 * 2.  Validating that required columns are present in the imported file.
 * 3.  Converting raw string values from rows into a structured [NotificationModel].
 *
 * It is designed to be a stateless helper, making it safe for use as a singleton.
 */
object NotificationImportMapper {
    private const val KEY_PACKAGE_NAME = "packagename"
    private const val KEY_POST_TIME = "posttime"
    private const val KEY_PRIORITY = "priority"
    private const val KEY_CATEGORY = "category"
    private const val KEY_TEXT_LINES = "textlines"
    private const val KEY_TITLE = "title"
    private const val KEY_TEXT = "text"
    private const val KEY_SUB_TEXT = "subtext"
    private const val KEY_BIG_TEXT = "bigtext"
    private const val KEY_SUMMARY_TEXT = "summarytext"
    private const val KEY_INFO_TEXT = "infotext"
    private const val KEY_SMALL_ICON_RES_ID = "smalliconresid"
    private const val KEY_ICON_BASE64 = "iconbase64"
    private const val KEY_GROUP_KEY = "groupkey"
    private const val KEY_CHANNEL_ID = "channelid"
    private const val KEY_IS_READ = "isread"
    private const val KEY_IS_BOOKMARKED = "isbookmarked"

    /**
     * Creates a map from normalized header names to their column index.
     *
     * @param header The list of header strings from the first row of the file.
     * @return A map where the key is the normalized header name (e.g., "packagename")
     *         and the value is its zero-based column index.
     */
    fun headerMap(header: List<String>): Map<String, Int> {
        return header
            .mapIndexed { index, name -> normalizeHeader(name) to index }
            .toMap()
    }

    /**
     * Validates that all required columns are present in the header map.
     *
     * @param headerMap The map generated by [headerMap].
     * @throws IllegalArgumentException If one or more required columns are missing.
     */
    fun validateHeader(headerMap: Map<String, Int>) {
        val required = listOf(
            KEY_PACKAGE_NAME,
            KEY_POST_TIME,
            KEY_PRIORITY,
            KEY_CATEGORY
        )
        val missing = required.filterNot { headerMap.containsKey(it) }
        if (missing.isNotEmpty()) {
            throw IllegalArgumentException("Missing required columns: ${missing.joinToString()}")
        }
    }

    /**
     * Converts a single row of data into a [NotificationModel].
     *
     * @param row A list of strings representing the cells in a single data row.
     * @param headerMap The map of header names to indices, used to look up values correctly.
     * @return A fully populated [NotificationModel].
     * @throws IllegalArgumentException If a required field (packageName, postTime, etc.)
     *         is missing, blank, or in an invalid format.
     */
    fun toNotification(
        row: List<String>,
        headerMap: Map<String, Int>
    ): NotificationModel {
        fun value(key: String): String? = headerMap[key]?.let { index ->
            row.getOrNull(index)?.trim()
        }

        val packageName = value(KEY_PACKAGE_NAME).orEmpty()
        val postTime = value(KEY_POST_TIME)?.toLongOrNull()
        val priority = value(KEY_PRIORITY)?.toIntOrNull()
        val category = value(KEY_CATEGORY).orEmpty()

        if (packageName.isBlank() || postTime == null || priority == null || category.isBlank()) {
            throw IllegalArgumentException("Invalid row format")
        }

        val textLinesRaw = value(KEY_TEXT_LINES).orEmpty()
        val textLines = if (textLinesRaw.isBlank()) {
            null
        } else {
            textLinesRaw
                .replace("\\\\n", "\n")
                .replace("\\n", "\n")
                .replace("\r\n", "\n")
                .split("\n")
                .map { it.trimEnd('\\') }
        }

        return NotificationModel(
            packageName = packageName,
            title = value(KEY_TITLE).ifBlankToNull(),
            text = value(KEY_TEXT).ifBlankToNull(),
            subText = value(KEY_SUB_TEXT).ifBlankToNull(),
            bigText = value(KEY_BIG_TEXT).ifBlankToNull(),
            summaryText = value(KEY_SUMMARY_TEXT).ifBlankToNull(),
            infoText = value(KEY_INFO_TEXT).ifBlankToNull(),
            textLines = textLines,
            postTime = postTime,
            priority = priority,
            category = category,
            smallIconResId = value(KEY_SMALL_ICON_RES_ID)?.toIntOrNull(),
            iconBase64 = value(KEY_ICON_BASE64).ifBlankToNull(),
            groupKey = value(KEY_GROUP_KEY).ifBlankToNull(),
            channelId = value(KEY_CHANNEL_ID).ifBlankToNull(),
            isRead = value(KEY_IS_READ).toBooleanStrictSafe(),
            isBookmarked = value(KEY_IS_BOOKMARKED).toBooleanStrictSafe()
        )
    }

    /**
     * Normalizes a header string by trimming whitespace, removing the BOM (Byte Order Mark),
     * and converting it to lowercase for case-insensitive comparison.
     */
    private fun normalizeHeader(header: String): String {
        // The \uFEFF BOM character can appear at the start of UTF-8 files (especially from Windows).
        return header.trim().removePrefix("\uFEFF").lowercase()
    }

    /**
     * Extension function that converts a blank or null string to null.
     * Useful for optional fields.
     */
    private fun String?.ifBlankToNull(): String? {
        val value = this?.trim().orEmpty()
        return value.ifBlank { null }
    }

    /**
     * Safely converts a string to a boolean. Returns `true` only for the string "true"
     * (case-insensitive), and `false` for all other values including null.
     */
    private fun String?.toBooleanStrictSafe(): Boolean {
        return this?.trim()?.equals("true", ignoreCase = true) == true
    }
}
